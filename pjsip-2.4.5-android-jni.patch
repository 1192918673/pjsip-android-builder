diff -Naur pjproject-2.4.5/pjmedia/src/pjmedia-audiodev/android_jni_dev.c pjproject-2.4.5-android-jni/pjmedia/src/pjmedia-audiodev/android_jni_dev.c
--- pjproject-2.4.5/pjmedia/src/pjmedia-audiodev/android_jni_dev.c	2015-08-10 09:11:39.000000000 +0000
+++ pjproject-2.4.5-android-jni/pjmedia/src/pjmedia-audiodev/android_jni_dev.c	2016-03-06 16:15:19.000000000 +0000
@@ -265,6 +265,17 @@
      */
     set_android_thread_priority(THREAD_PRIORITY_URGENT_AUDIO);
     (*jni_env)->CallVoidMethod(jni_env, stream->record, record_method);
+    pj_timestamp now, last_frame, tstamp;
+    pj_get_timestamp(&last_frame);
+    
+    // throttle reading start
+    int nframes = stream->param.samples_per_frame / stream->param.channel_count;
+    int elapsed_time = 0;
+    int frame_time = nframes * 1000 / stream->param.clock_rate;
+    int missed_time = frame_time;
+    int to_wait = 0;
+    tstamp.u64 = 0;
+    // throttle reading end
     
     while (!stream->quit_flag) {
         pjmedia_frame frame;
@@ -277,8 +288,34 @@
             if (stream->quit_flag)
                 break;
             (*jni_env)->CallVoidMethod(jni_env, stream->record, record_method);
+            pj_get_timestamp(&last_frame);
         }
         
+        // throttle reading start
+        pj_get_timestamp(&now);
+        
+        // Time between now and last frame next frame (ms)
+        elapsed_time = pj_elapsed_msec(&last_frame, &now);
+        
+        pj_get_timestamp(&last_frame);
+        
+        //Update missed time
+        // Positive if we are late
+        // Negative if we are earlier
+        // dividing by 2 is empiric result
+        // on N1 if not we get buffer overflow I assume that it fill packets faster than the frequency
+        missed_time = missed_time / 2 + elapsed_time - frame_time;
+        
+        //If we go faster than the buffer filling, we have to wait
+        if (missed_time <= 0) {
+            to_wait = - missed_time - 2;
+            if (to_wait > 0) {
+                //PJ_LOG (4, (THIS_FILE, "Faster than the buffer filling. Wait for %d / %d", to_wait, frame_time));
+                pj_thread_sleep(to_wait);
+            }
+        }
+        // throttle reading end
+        
         bytesRead = (*jni_env)->CallIntMethod(jni_env, stream->record,
                                               read_method, inputBuffer,
                                               0, size);
@@ -297,12 +334,12 @@
 
         status = (*stream->rec_cb)(stream->user_data, &frame);
         (*jni_env)->ReleaseByteArrayElements(jni_env, inputBuffer, buf,
-        				     JNI_ABORT);
-	if (status != PJ_SUCCESS || stream->quit_flag)
-	    break;
-
-        stream->rec_timestamp.u64 += stream->param.samples_per_frame /
-                                     stream->param.channel_count;
+                                             JNI_ABORT);
+        if (status != PJ_SUCCESS || stream->quit_flag)
+            break;
+        
+        stream->rec_timestamp.u64 += nframes;
+        tstamp.u64 += nframes;
     }
 
     (*jni_env)->DeleteLocalRef(jni_env, inputBuffer);
